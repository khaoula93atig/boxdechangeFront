{"version":3,"file":"stomp-r.service.d.ts","sources":["stomp-r.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { RxStomp } from '@stomp/rx-stomp';\nimport { publishParams, Client, Message, Frame } from '@stomp/stompjs';\nimport { BehaviorSubject, Observable, Subject } from 'rxjs';\nimport { StompState } from './stomp-state';\nimport { StompHeaders } from './stomp-headers';\nimport { StompConfig } from './stomp.config';\n/**\n * Part of `@stomp/ng2-stompjs`.\n *\n * **This class has been deprecated in favor of {@link RxStompService}.\n * It will be dropped `@stomp/ng2-stompjs@8.x.x`.**\n *\n * Angular2 STOMP Raw Service using @stomp/stomp.js\n *\n * You will only need the public properties and\n * methods listed unless you are an advanced user. This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\nexport declare class StompRService extends RxStomp {\n    /**\n     * State of the STOMPService\n     *\n     * It is a BehaviorSubject and will emit current status immediately. This will typically get\n     * used to show current status to the end user.\n     */\n    state: BehaviorSubject<StompState>;\n    private static _mapStompState(st);\n    /**\n     * Will trigger when connection is established. Use this to carry out initialization.\n     * It will trigger every time a (re)connection occurs. If it is already connected\n     * it will trigger immediately. You can safely ignore the value, as it will always be\n     * StompState.CONNECTED\n     */\n    readonly connectObservable: Observable<StompState>;\n    /**\n     * Provides headers from most recent connection to the server as return by the CONNECTED\n     * frame.\n     * If the STOMP connection has already been established it will trigger immediately.\n     * It will additionally trigger in event of reconnection, the value will be set of headers from\n     * the recent server response.\n     */\n    readonly serverHeadersObservable: Observable<StompHeaders>;\n    /**\n     * Will emit all messages to the default queue (any message that are not handled by a subscription)\n     */\n    readonly defaultMessagesObservable: Subject<Message>;\n    /**\n     * Will emit all receipts\n     */\n    readonly receiptsObservable: Subject<Frame>;\n    /**\n     * Will trigger when an error occurs. This Subject can be used to handle errors from\n     * the stomp broker.\n     */\n    readonly errorSubject: Subject<string | Frame>;\n    /** Set configuration */\n    config: StompConfig;\n    /**\n     * It will connect to the STOMP broker.\n     */\n    initAndConnect(): void;\n    /**\n     * It will disconnect from the STOMP broker.\n     */\n    disconnect(): void;\n    /**\n     * It will send a message to a named destination. The message must be `string`.\n     *\n     * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n     * publish queued messages as soon as the broker gets connected.\n     *\n     * @param queueName\n     * @param message\n     * @param headers\n     */\n    publish(queueName: string | publishParams, message?: string, headers?: StompHeaders): void;\n    /**\n     * It will subscribe to server message queues\n     *\n     * This method can be safely called even if the STOMP broker is not connected.\n     * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.\n     *\n     * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n     * do not understand what it means, please leave it as is.\n     *\n     * Note that when working with temporary queues where the subscription request\n     * creates the\n     * underlying queue, messages might be missed during reconnect. This issue is not specific\n     * to this library but the way STOMP brokers are designed to work.\n     *\n     * @param queueName\n     * @param headers\n     */\n    subscribe(queueName: string, headers?: StompHeaders): Observable<Message>;\n    /**\n     * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n     * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n     * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n     * random number or a combination may be used.\n     *\n     * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n     * The operation needs to be matched based in the value of the receipt-id.\n     *\n     * This method allow watching for a receipt and invoke the callback\n     * when corresponding receipt has been received.\n     *\n     * The actual {@link Frame}\n     * will be passed as parameter to the callback.\n     *\n     * Example:\n     * ```javascript\n     *        // Publishing with acknowledgement\n     *        let receiptId = randomText();\n     *\n     *        rxStomp.waitForReceipt(receiptId, function() {\n     *          // Will be called after server acknowledges\n     *        });\n     *        rxStomp.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\n     * ```\n     *\n     * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\n     */\n    waitForReceipt(receiptId: string, callback: (frame: Frame) => void): void;\n    readonly client: Client;\n    constructor();\n}\n"]}